mover Atomic_21
split if Atomic_27
merge proc AQS_addWaiter
mover Atomic_21
merge proc AQS_addWaiter
mover Atomic_21
merge proc AQS_addWaiter
mover Atomic_21
merge proc AQS_addWaiter
simulate Atomic_21 done := false;         currentThread := Threads[tid];         node := New Node;         owner[node] := tid;         assume node != NULL_NODE;         node.nextWaiter := mode;         node.thread := currentThread;         node.next := NULL_NODE;         node.prev := NULL_NODE;         node.waitStatus := NO_WAIT_STATUS;         con[node] := True;         havoc abst_NonfairSync_tail_0;         pred := abst_NonfairSync_tail_0[this];         if (pred != NULL_NODE)         {             node.prev := pred;             havoc dummy;             if (this.tail == pred)             {                 this.tail := node;                 assert pred.alloc == Alloc;                 assert con[pred] == True;                 pred.next := node;                 result := node;                 done := true;             }         }          if (!done)         {             havoc fresh_0;             if (this.tail == NULL_NODE)             {                 fresh_1 := New Node;                 owner[fresh_1] := tid;                 assume fresh_1 != NULL_NODE;                 fresh_1.prev := NULL_NODE;                 fresh_1.next := NULL_NODE;                 fresh_1.nextWaiter := NULL_NODE;                 fresh_1.thread := NULL_THREAD;                 fresh_1.waitStatus := NO_WAIT_STATUS;                 con[fresh_1] := True;                 fresh_1.next := node;                 node.prev := fresh_1;                 this.head := fresh_1;                 this.tail := node;                 dummyNode := fresh_1;             }             else             {                 assert this.tail.alloc == Alloc;                 assert con[this.tail] == True;                 node.prev := this.tail;                 this.tail := node;                 node.prev.next := node;                 dummyNode := node.prev;             }              result := node;         }
simulate Atomic_21 havoc dummyNode; done := false;         havoc currentThread;         node := New Node;         owner[node] := tid;         assume node != NULL_NODE;         node.nextWaiter := mode;         node.thread := Threads[tid];         node.next := NULL_NODE;         node.prev := NULL_NODE;         node.waitStatus := NO_WAIT_STATUS;         con[node] := True;         havoc abst_NonfairSync_tail_0;         pred := abst_NonfairSync_tail_0[this];         node.prev := pred;             havoc dummy;             if (this.tail == pred)         {                 this.tail := node;                 assert pred.alloc == Alloc;                 assert con[pred] == True;                 pred.next := node;                 result := node;                 done := true;         }          if (!done)         {             havoc fresh_0;             if (this.tail == NULL_NODE)             {                 fresh_1 := New Node;                 owner[fresh_1] := tid;                 assume fresh_1 != NULL_NODE;                 fresh_1.prev := NULL_NODE;                 fresh_1.nextWaiter := NULL_NODE;                 fresh_1.thread := NULL_THREAD;                 fresh_1.waitStatus := NO_WAIT_STATUS;                 con[fresh_1] := True;                 fresh_1.next := node;                 node.prev := fresh_1;                 this.head := fresh_1;                 this.tail := node;             }             else             {                 assert this.tail.alloc == Alloc;                 assert con[this.tail] == True;                 node.prev := this.tail;                 this.tail := node;                 node.prev.next := node;             }              result := node;         }
