reduce proc Contains
simulate Atomic_17 havoc qseq, cseq, qcount, curr; assume (qseq[0] <= Hcount); assume (cseq[0] == Head); assume qcount >= 1; assume (forall j:int :: 0 < j && j < qcount ==> qseq[j-1] <= qseq[j] && qseq[j] <= Hcount); assume (forall j:int :: 0 < j && j < qcount ==> Hnext[qseq[j]][cseq[j-1]] == cseq[j]); assume (forall j:int :: 0 <= j && j < qcount-1 ==> cseq[j].val < e); assume curr == cseq[qcount-1]; guard := curr.val < e;
peelout Atomic_19
reduce loop2 Atomic_17
reduce proc Contains
simulate Atomic_17 assume (forall s: int, t: int, k: int, m: Node, n: Node :: s <= t && t <= Hcount && Hver[s][k] == Hver[t][k] && IsOut(Head, Hnext[s], Hmarked[s], Node_val, k) && ReachBetween(Hnext[t], m, n, n) && ReachBetween(Hnext[s], Head, m, m) ==> n.val != k || n.marked == True);         havoc qseq, cseq, qcount, curr;         assume qseq[0] <= Hcount;         assume cseq[0] == Head;         assume qcount >= 1;         assume (forall j: int :: 0 < j && j < qcount ==> qseq[j - 1] <= qseq[j] && qseq[j] <= Hcount);         assume (forall j: int :: 0 < j && j < qcount ==> Hnext[qseq[j]][cseq[j - 1]] == cseq[j]);         assume (forall j: int :: 0 <= j && j < qcount - 1 ==> cseq[j].val < e);         assume curr == cseq[qcount - 1];         assume curr.val >= e;         assume qseq[qcount - 1] <= qseq[qcount] && qseq[qcount] <= Hcount;         marked := Hmarked[qseq[qcount]][curr] == True;         qcount := qcount + 1;         if (marked)         {             res := false;         }         else         {             res := curr.val == e;         } havoc guard;          assert ((forall i: int :: 0 <= i && i <= qseq[qcount - 1] ==> IsIn(Head, Hnext[i], Hmarked[i], Node_val, e)) ==> res) && ((forall i: int :: 0 <= i && i <= qseq[qcount - 1] ==> IsOut(Head, Hnext[i], Hmarked[i], Node_val, e)) ==> !res);