inline all
reduce all
assert Atomic_5 h.alloc == Alooc
assert Atomic_5 h.alloc == Alloc
assert Atomic_6 node.alloc == Alloc
assert Atomic_11 node.alloc == Alloc
assert Atomic_19 t.alloc == Alloc
reduce all
mover Atomic_3
aux intro owner [Node]int
aux remove owner
assert Atomic_3 owner[node] == tid
mover Atomic_3
assert Atomic_11 owner[node] == tid
mover Atomic_3
reduce all
mover Atomic_3
mover Atomic_18
simulate Atomic_18 if (dummy)                 { assert this.head == h; assert this.tail == NULL_NODE; assert h.alloc == Alloc; assert node.alloc == Alloc;                     this.tail := node;                      result := h;                      return;                 }
mover Atomic_18
invariant NULL_NODE.alloc == Null
mover Atomic_18
assert Atomic_18 owner[node] == tid
mover Atomic_18
assert Atomic_11 t.alloc == Alloc
mover Atomic_18
mover Atomic_3
mover Atomic_18
mover Atomic_18
hoist Atomic_2 after
mover Atomic_2_else
mover Atomic_2_else
simulate Atomic_2_else t := this.tail;                  assume t != NULL_NODE; havoc t;
mover Atomic_2_else
merge all
mover Atomic_18
simulate Atomic_2 t := this.tail;                  assume t == NULL_NODE; havoc t;
mover Atomic_2
mover Atomic_18
simulate Atomic_2 havoc t;
mover Atomic_18
merge all
reduce all
check all block
check all block
mover all
simulate Atomic_23 if (*)             {                 havoc t;                  assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     return;                 }             }             else             {                 assume this.tail != NULL_NODE;                 havoc t;                  assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     return;                 }             }         } havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                  assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     return;                 }             }             else             {                 assume this.tail != NULL_NODE;                 havoc t;                  assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     return;                 }             }  havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                  assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h; havoc dummy;                     return;                 }             }             else             {                 assume this.tail != NULL_NODE;                 havoc t;                  assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t; havoc dummy;                     return;                 }             }  havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                  assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h; havoc dummy;                     return;                 }             }             else             {                 assume this.tail != NULL_NODE;                 havoc t;                  assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t; havoc dummy;                     return;                 }             }  havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                  assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h; havoc dummy;                              return;                 }             }             else             {                 assume this.tail != NULL_NODE;                 havoc t;                  assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t; havoc dummy;                     return;                 }             }  havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                 assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.next := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 dummy := this.head == NULL_NODE;                 if (dummy)                 {                     this.head := h;                 }                  if (dummy)                 {                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h; havoc dummy;                     return;                 }             }             else             {                 t := this.tail;                 assume t != NULL_NODE;                 havoc t;                 assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 dummy := this.tail == t;                 if (dummy)                 {                     this.tail := node;                 }                  if (dummy)                 {                     t.next := node;                     result := t; havoc dummy;                     return;                 }             } havoc dummy;
simulate Atomic_23 if (*)             {                 havoc t;                 assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.next := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     havoc dummy;                     return;                 }             }             else             {                 t := this.tail;                 assume t != NULL_NODE;                 havoc t;                 assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     havoc dummy;                     return;                 }             }              havoc dummy;         }
simulate Atomic_23 if (*)             {                 havoc t;                 assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.next := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     havoc dummy;                     return;                 }             }             else             {                 t := this.tail;                 assume t != NULL_NODE;                 havoc t;                 assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     havoc dummy;                     return;                 }             }              havoc dummy;
mover Atomic_23
peelout Atomic_23
simulate Atomic_23 if (*)                 {                     havoc t;                     assert owner[node] == tid;                     h := New Node;                     h.prev := NULL_NODE;                     h.next := NULL_NODE;                     h.nextWaiter := NULL_NODE;                     h.thread := NULL_THREAD;                     h.waitStatus := NO_WAIT_STATUS;                     h.next := node;                     assert node.alloc == Alloc;                     node.prev := h;                     if (this.head == NULL_NODE)                     {                         this.head := h;                         assert this.tail == NULL_NODE;                         this.tail := node;                         result := h;                         havoc dummy;                         assume false;                     }                 }                 else                 {                     t := this.tail;                     assume t != NULL_NODE;                     havoc t;                     assert t.alloc == Alloc;                     assert owner[node] == tid;                     assert node.alloc == Alloc;                     node.prev := t;                     if (this.tail == t)                     {                         this.tail := node;                         t.next := node;                         result := t;                         havoc dummy; assume false;                     }                 }                  havoc dummy;
mover Atomic_23
reduce loop Atomic_23 if(*) { if (*)             {                 havoc t;                 assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.next := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     havoc dummy;                     assume false;                 }             }             else             {                 t := this.tail;                 assume t != NULL_NODE;                 havoc t;                 assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     havoc dummy;                     assume false;                 }             }              havoc dummy; }
reduce loop Atomic_23 if (*)             {                 havoc t;                 assert owner[node] == tid;                 h := New Node;                 h.prev := NULL_NODE;                 h.next := NULL_NODE;                 h.nextWaiter := NULL_NODE;                 h.thread := NULL_THREAD;                 h.waitStatus := NO_WAIT_STATUS;                 h.next := node;                 assert node.alloc == Alloc;                 node.prev := h;                 if (this.head == NULL_NODE)                 {                     this.head := h;                     assert this.tail == NULL_NODE;                     this.tail := node;                     result := h;                     havoc dummy;                     assume false;                 }             }             else             {                 t := this.tail;                 assume t != NULL_NODE;                 havoc t;                 assert t.alloc == Alloc;                 assert owner[node] == tid;                 assert node.alloc == Alloc;                 node.prev := t;                 if (this.tail == t)                 {                     this.tail := node;                     t.next := node;                     result := t;                     havoc dummy;                     assume false;                 }             }              havoc dummy;
